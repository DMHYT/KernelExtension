#include <Actor.hpp>

#ifndef KEX_MOB_HPP
#define KEX_MOB_HPP


class BaseAttributeMap;
#ifndef KEX_BLOCK_HPP
    class Block;
#endif
class CompoundTag;
class DataLoadHelper;
class GoalDefinition;
class IMobMovementProxy;
class ListTag;
namespace mce {
    class UUID;
}
class SynchedActorData;
#ifndef KEX_VEC2_HPP
    class Vec2;
#endif
class VillageLegacy;

class Mob : public Actor {
    public:
    // virtual void reloadHardcoded(Actor::InitializationMethod, const VariantParameterList&);
    // virtual void reloadHardcodedClient(Actor::InitializationMethod, const VariantParameterList&);
    // virtual void initializeComponents(Actor::InitializationMethod, const VariantParameterList&);
    // virtual void _doInitialMove();
    // virtual bool hasComponent(const HashedString&) const;
    // virtual Vec2* getInterpolatedBodyRot(float) const;
    // virtual Vec2* getInterpolatedHeadRot(float) const;
    // virtual float getInterpolatedBodyYaw(float) const;
    // virtual float getYawSpeedInDegreesPerSecond() const;
    // virtual bool blockedByShield(const ActorDamageSource&, Actor&);
    // virtual void teleportTo(const Vec3&, bool, int, int, const ActorUniqueID&);
    // virtual void lerpTo(const Vec3&, const Vec2&, int);
    // virtual void normalTick();
    // virtual void baseTick();
    // virtual void rideTick();
    // virtual void startRiding(Actor&);
    // virtual void addRider(Actor&);
    // virtual bool isImmobile() const;
    // virtual bool isPickable() const;
    // virtual bool isSleeping() const;
    // virtual bool isShootable() const;
    // virtual bool isBlocking() const;
    // virtual bool isAlive() const;
    // virtual bool isSurfaceMob() const;
    // virtual void setTarget(Actor*);
    // virtual void attack(Actor&);
    // virtual bool canPowerJump() const;
    // virtual bool isJumping() const;
    // virtual void* getBlockDamageCause(const Block&) const;
    // virtual void actuallyHurt(int, const ActorDamageSource&, bool);
    // virtual void animateHurt();
    // virtual void doFireHurt(int);
    // virtual void handleEntityEvent(ActorEvent, int);
    // virtual MaterialType getArmorMaterialTypeInSlot(ArmorSlot) const;
    // virtual ArmorTextureType getArmorMaterialTextureTypeInSlot(ArmorSlot) const;
    // virtual void* getArmorColorInSlot(ArmorSlot, int) const;
    // virtual void setEquippedSlot(EquipmentSlot, const ItemStack&);
    // virtual void setOnFire(int);
    // virtual void causeFallDamage(float);
    // virtual bool canBePulledIntoVehicle() const;
    // virtual bool inCaravan() const;
    // virtual void stopRiding(bool, bool, bool);
    // virtual void* buildDebugInfo(stl::string&) const;
    // virtual int getDeathTime() const;
    // virtual void swing();
    // virtual float getYHeadRot() const;
    // virtual void renderDebugServerState(const Options&);
    // virtual void kill();
    // virtual void die(const ActorDamageSource&);
    // virtual void createMovementProxy();
    // virtual void updateEntitySpecificMolangVariables(RenderParams&);
    // virtual bool outOfWorld();
    // virtual void _hurt(const ActorDamageSource&, int, bool, bool);
    // virtual void readAdditionalSaveData(const CompoundTag&, DataLoadHelper&);
    // virtual void addAdditionalSaveData(CompoundTag&);
    // virtual void _playStepSound(const BlockPos&, const Block&);
    // virtual void _removeRider(const ActorUniqueID&, bool, bool, bool);
    // virtual void _onSizeUpdated();
    // virtual void knockback(Actor*, int, float, float, float, float, float);
    // virtual void resolveDeathLoot(int, const ActorDamageSource&);
    // virtual void spawnAnim();
    // virtual void setSleeping(bool);
    // virtual void setSprinting(bool);
    // virtual void playAmbientSound();
    // virtual void* getAmbientSound();
    // virtual int getAmbientSoundPostponeTicks();
    // virtual void* getAmbientSoundPostponeTicksRange();
    // virtual void* getItemInHandIcon(const ItemStack&, int);
    // virtual float getSpeed() const;
    // virtual void setSpeed(float);
    // virtual float getJumpPower() const;
    // virtual void hurtEffects(const ActorDamageSource&, int, bool, bool);
    // virtual int getMeleeWeaponDamageBonus(Mob*);
    // virtual float getMeleeKnockbackBonus();
    // virtual void* travel(float, float, float);
    // virtual void* travel(IMobMovementProxy&, float, float, float) const;
    // virtual void applyFinalFriction(float, bool);
    // virtual void updateWalkAnim();
    // virtual void aiStep();
    // virtual void aiStep(IMobMovementProxy&) const;
    // virtual void pushActors();
    // virtual void lookAt(Actor*, float, float);
    // virtual bool isLookingAtAnEntity();
    // virtual void* checkSpawnRules(bool);
    // virtual void* checkSpawnObstruction() const;
    // virtual void* getAttackAnim(float);
    // virtual int getItemUseDuration();
    // virtual float getItemUseStartupProgress();
    // virtual float getItemUseIntervalProgress();
    // virtual void* getItemuseIntervalAxis();
    // virtual void* getTimeAlongSwing();
    // virtual void ate();
    // virtual float getMaxHeadXRot();
    // virtual Mob* getLastHurtByMob();
    // virtual void setLastHurtByMob(Mob*);
    // virtual Player* getLastHurtByPlayer();
    // virtual void setLastHurtByPlayer(Player*);
    // virtual Actor* getLastHurtMob();
    // virtual void setLastHurtMob(Actor*);
    // virtual bool isAlliedTo(Mob*);
    // virtual void doHurtTarget(Actor*);
    // virtual bool canBeControlledByRider();
    // virtual void leaveCaravan();
    // virtual void joinCaravan(Mob*);
    // virtual bool hasCaravanTail() const;
    // virtual Mob* /*?*/ getCaravanHead() const;
    // virtual int getArmorValue();
    // virtual float getArmorCoverPercentage() const;
    // virtual void hurtArmor(const ActorDamageSource&, int);
    // virtual void hurtArmor(const ActorDamageSource&, int, const stl::bitset<4u>&);
    // virtual void hurtArmorSlot(const ActorDamageSource&, int, ArmorSlot);
    // virtual void setDamagedArmor(ArmorSlot, const ItemStack&);
    // virtual void sendArmorDamage(const stl::bitset<4u>&);
    // virtual void sendArmor(const stl::bitset<4u>&);
    // virtual void containerChanged(int);
    // virtual void updateEquipment();
    // virtual void clearEquipment();
    // virtual void* getAllArmor() const;
    // virtual void* getAllArmorID() const;
    // virtual void* getAllHand() const;
    // virtual void* getAllEquipment() const;
    // virtual HashedString& getArmorTypeHash();
    // virtual void dropEquipmentOnDeath(const ActorDamageSource&, int);
    // virtual void dropEquipmentOnDeath();
    // virtual void clearVanishEnchantedItemsOnDeath();
    // virtual void sendInventory(bool);
    // virtual int getDamageAfterMagicAbsorb(const ActorDamageSource&, int);
    // virtual void clearAIGoals();
    // virtual void onBorn(Actor&, Actor&);
    // virtual void setItemSlot(EquipmentSlot, const ItemStack&);
    // virtual void setTransitioningSitting(bool);
    // virtual void attackAnimation(Actor*, float);
    // virtual void* getAttackTime();
    // virtual void* _getWalkTargetValue(const BlockPos&);
    // virtual bool canExistWhenDisallowMob() const;
    // virtual void* useNewAi() const;
    // virtual void ascendLadder();
    // virtual void ascendScaffolding();
    // virtual void descendScaffolding();
    // virtual void dropContainer();
    // virtual void initBodyControl();
    // virtual void* jumpFromGround();
    // virtual void* jumpFromGround(IMobMovementProxy&) const;
    // virtual void updateAi();
    // virtual void newServerAiStep();
    // virtual void _serverAiMobStep();
    // virtual int getDamageAfterEnchantReduction(const ActorDamageSource&, int);
    // virtual int getDamageAfterArmorAbsorb(const ActorDamageSource&, int);
    // virtual void dropBags();
    // virtual void tickDeath();
    // virtual void updateGliding();
    // virtual bool _allowAscendingScaffolding() const;
    bool _isNewEntityAttack(ActorDamageCause) const;
    int getNoActionTime() const;
    void setWantsToBeJockey(bool);
    void playBornSound();
    void setSprinting(BaseAttributeMap&, SynchedActorData&, bool);
    int _getDamageAfterAbsorb(int, int);
    bool isLayingEgg() const;
    void lerpTo(const Vec3&, const Vec2&, float, int);
    void* saveOffhand() const;
    int getGlidingTicks() const;
    bool wantsToBeJockey() const;
    void setFrictionModifier(float);
    bool isTransitioningSitting() const;
    void snapToYBodyRot(float);
    void incrementArrowCount(int);
    bool canPickUpLoot(const ItemStack&) const;
    float getJumpMultiplier(const IMobMovementProxy&);
    bool _shouldDropItem(const ItemStack&, bool, bool, int, float) const;
    void _addSpeedBonus(const mce::UUID&, const stl::string&, float);
    bool hasBeenHurtByMobInLastTicks(int) const;
    void _saveArmor();
    ItemStack* getItemSlot(EquipmentSlot) const;
    bool _isHeadInWater();
    float getMovementComponentCurrentSpeed() const;
    Mob* getJumpPrevention(const IMobMovementProxy&);
    ActorUniqueID* getTargetCaptain() const;
    void _initHardCodedComponents();
    void processSoulSpeed();
    float getFlightSpeed();
    void setInterpolation(bool);
    void _tryApplyingLevitation(const IMobMovementProxy&, Vec3&);
    bool checkTotemDeathProtection(const ActorDamageSource&);
    void _updateSprintingState();
    void stopAI();
    void setYHeadRot(float);
    void setRiderRotLimit(float);
    int getRollCounter() const;
    MobSpawnMethod getSpawnMethod();
    void resetNoActionTime();
    bool isJumpOnBlockPrevented(const IMobMovementProxy&, const BlockPos&);
    void setXxa(float);
    float getRiderLockedBodyRot() const;
    int getCurrentSwingDuration();
    void setRiderLockedBodyRot(float);
    void setSpawnMethod(MobSpawnMethod);
    float getYya() const;
    bool isFrostWalking() const;
    void _jumpFromGround(IMobMovementProxy&);
    void updateGlidingDurability();
    void setJumpVelRedux(bool);
    float calcMoveRelativeSpeed(TravelType);
    bool isEating() const;
    float _getExpectedFallDamage(float) const;
    void tickAttributes();
    void setRolling(bool);
    void emitJumpPreventedEvent(const BlockPos&);
    void setEating(bool);
    TravelType getTravelType(const IMobMovementProxy&);
    void _verifyAttributes();
    int getLastHurtByMobTimestamp();
    void sendArmorDamageSlot(ArmorSlot);
    void _endJump();
    void setTargetCaptain(ActorUniqueID);
    void _doSprintParticleEffect();
    bool hasBoundOrigin() const;
    int getLastHurtByMobTime();
    float getJumpMultiplier();
    VillageLegacy* /*?*/ getVillageLegacy() const;
    void setIsPregnant(bool);
    bool isRolling() const;
    float getYRotA() const;
    void snapToYHeadRot(float);
    void setNaturallySpawned(bool);
    void resetAttributes();
    void _travel(IMobMovementProxy&, float, float, float);
    ActorDamageCause getLastHurtCause() const;
    void createAI(stl::vector<GoalDefinition>);
    void setZza(float);
    TravelType getTravelType();
    void tickEffects();
    void setSurfaceMob(bool);
    bool isPregnant() const;
    void setIsLayingEgg(bool);
    float getXxa() const;
    // void onPlayerDimensionChanged(Player*, AutomaticID<Dimension, int>);
    float getRiderRotLimit() const;
    void setMovementComponentCurrentSpeed(float);
    BlockPos& getBoundOrigin() const;
    int calculateAmbientSoundTime(int);
    void sendArmorAllSlots();
    void frostWalk();
    int getCaravanSize() const;
    void* saveMainhand() const;
    void setFlightSpeed(float);
    void setBoundOrigin(BlockPos);
    bool _isFloorDamaging(const BlockPos&);
    void loadMainhand(const ListTag*);
    bool isSprinting() const;
    void _doSoulSpeedParticleEffect();
    bool isInterpolationActive() const;
    Mob* getJumpPrevention();
    void _loadArmor(const ListTag*);
    int getLastHurtMobTimestamp();
    void _removeSpeedBonus(const mce::UUID&);
    bool shouldApplyWaterGravity();
    void _registerMobAttributes();
    bool isGliding() const;
    void setEatCounter(int);
    void loadOffhand(const ListTag*);
    Mob* getFirstCaravanHead();
    void setYRotA(float);
    void updateAttackAnim();
    int getLastHurtTimestamp() const;
    bool isNaturallySpawned() const;
    void _aiStep(IMobMovementProxy&);
    void lerpToRotation(const Vec2&, int);
    float _calcMoveRelativeSpeed(IMobMovementProxy&, TravelType);
    void setJumping(bool);
    void setSpeedModifier(float);
    void setYya(float);
    void _updateMobId(ActorUniqueID&);
    bool _shouldPreserveItemDurability(const ItemStack&, float) const;
    void sendArmorSlot(ArmorSlot);
    bool isSwinging() const;
    void playSpawnSound();
    float getZza() const;
    int calculateJumpImpulse();
    void _updateMobTravel(IMobMovementProxy&);
    int getEatCounter() const;
    float getFrictionModifier() const;
};


#endif //KEX_BLOCK_HPP